<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Typographic Watermarking: AI Text Attribution via Unicode Substitution</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      /* Colors */
      --color-bg-paper: #ffffff;
      --color-bg-tool: #fcfcfc;
      --color-text-main: #111111;
      --color-text-muted: #666666;
      --color-border: #e0e0e0;
      --color-border-strong: #000000;
      --color-accent: #000000;
      --color-highlight: #fff000;

      /* Source Colors */
      --color-chatgpt: #10a37f;
      --color-claude: #d97706;
      --color-gemini: #4285f4;
      --color-copilot: #0078d4;
      --color-perplexity: #8b5cf6;
      --color-poe: #7c3aed;
      --color-regular: #cccccc;

      /* Spacing */
      --space-xs: 4px;
      --space-s: 8px;
      --space-m: 16px;
      --space-l: 24px;
      --space-xl: 40px;

      /* Typography */
      --font-main: -apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      --font-mono: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
    }

    body {
      font-family: var(--font-main);
      font-size: 13px;
      background: var(--color-bg-paper);
      color: var(--color-text-main);
      height: 100vh;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .split-container {
      display: flex;
      height: 100vh;
    }

    /* LEFT: Research Paper */
    .paper-side {
      width: 50vw;
      height: 100vh;
      overflow-y: auto;
      padding: var(--space-xl);
      border-right: 2px solid var(--color-border-strong);
      background: var(--color-bg-paper);
    }

    .paper-header {
      margin-bottom: var(--space-l);
      padding-bottom: var(--space-m);
      border-bottom: 2px solid var(--color-border-strong);
    }

    .paper-title {
      font-size: 22px;
      font-weight: bold;
      line-height: 1.3;
      margin-bottom: 12px;
    }

    .paper-authors {
      font-size: 12px;
      color: #444;
      margin-bottom: 8px;
    }

    .paper-meta {
      font-size: 10px;
      color: var(--color-text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .section {
      margin-bottom: 28px;
    }

    .section-title {
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-bottom: 1px solid var(--color-border-strong);
      padding-bottom: var(--space-xs);
      margin-bottom: var(--space-m);
    }

    .section p {
      line-height: 1.7;
      margin-bottom: 12px;
      text-align: justify;
    }

    .citation {
      color: var(--color-copilot); /* Use a blue-ish token */
      text-decoration: none;
      cursor: pointer;
    }

    .citation:hover {
      text-decoration: underline;
    }

    .highlight {
      background: var(--color-highlight);
      padding: 0 2px;
    }

    code {
      font-family: var(--font-mono);
      font-size: 11px;
      background: #f4f4f4;
      padding: 2px 4px;
      border-radius: 3px;
    }

    .table-container {
      border: 2px solid var(--color-border-strong);
      margin: var(--space-m) 0;
    }

    .table-title {
      background: var(--color-border-strong);
      color: #fff;
      padding: 6px 10px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }

    th, td {
      padding: 8px 10px;
      text-align: left;
      border-bottom: 1px solid var(--color-border);
    }

    th {
      background: #f8f8f8;
      font-weight: 600;
      text-transform: uppercase;
      font-size: 10px;
      border-bottom: 2px solid var(--color-border-strong);
    }

    td:nth-child(2) { font-family: var(--font-mono); }

    .references {
      font-size: 11px;
      line-height: 1.6;
    }

    .ref-item {
      margin-bottom: 10px;
      padding-left: 20px;
      text-indent: -20px;
    }

    .ref-item a {
      color: var(--color-copilot);
      text-decoration: none;
    }

    .ref-item a:hover { text-decoration: underline; }

    /* RIGHT: Tool */
    .tool-side {
      position: fixed;
      right: 0;
      top: 0;
      width: 50vw;
      height: 100vh;
      background: var(--color-bg-tool);
      display: flex;
      flex-direction: column;
    }

    .tool-header {
      background: var(--color-bg-paper);
      border-bottom: 2px solid var(--color-border-strong);
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .tool-header-buttons {
      display: flex;
      gap: 4px;
    }

    .tool-header-button {
      width: 12px;
      height: 12px;
      border: 1px solid var(--color-border-strong);
      background: #fff;
    }

    .tool-header h2 {
      flex: 1;
      text-align: center;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .tool-content {
      flex: 1;
      padding: 24px;
      overflow-y: auto;
    }

    .field-label {
      font-weight: bold;
      margin-bottom: 6px;
      text-transform: uppercase;
      font-size: 10px;
      letter-spacing: 0.5px;
    }

    textarea {
      width: 100%;
      height: 160px;
      background: var(--color-bg-paper);
      border: 2px solid var(--color-border-strong);
      padding: var(--space-m);
      font-family: var(--font-mono);
      font-size: 11px;
      resize: none;
      outline: none;
      white-space: pre-wrap;
      transition: box-shadow 0.15s;
    }

    textarea:focus { box-shadow: 4px 4px 0 rgba(0,0,0,0.1); }
    textarea::placeholder { color: var(--color-text-muted); }

    .button-row {
      margin-top: var(--space-m);
      display: flex;
      justify-content: center;
    }

    button {
      padding: 10px 32px;
      background: var(--color-bg-paper);
      border: 2px solid var(--color-border-strong);
      color: var(--color-text-main);
      font-family: inherit;
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 3px 3px 0 var(--color-border-strong);
      transition: all 0.1s;
    }

    button:hover {
      background: var(--color-accent);
      color: #ffffff;
      transform: translate(-1px, -1px);
      box-shadow: 4px 4px 0 rgba(0,0,0,0.2);
    }
    button:active {
      transform: translate(2px, 2px);
      box-shadow: 1px 1px 0 var(--color-border-strong);
    }

    .result {
      margin-top: var(--space-l);
      border: 2px solid var(--color-border-strong);
      display: none;
      background: var(--color-bg-paper);
      box-shadow: 4px 4px 0 rgba(0,0,0,0.05);
    }

    .result.show { display: block; }

    .result-header {
      background: var(--color-border-strong);
      color: #fff;
      padding: 10px 14px;
      font-weight: 700;
      text-transform: uppercase;
      font-size: 10px;
      letter-spacing: 1px;
    }

    .result-body { padding: var(--space-m); }

    .detected-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #666;
      margin-bottom: 4px;
    }

    .detected-ai {
      font-size: 32px;
      font-weight: bold;
      letter-spacing: 2px;
      margin-bottom: 16px;
    }

    .detail-row {
      display: flex;
      border-bottom: 1px solid #ddd;
      padding: 8px 0;
      font-size: 11px;
    }

    .detail-row:last-child { border-bottom: none; }
    .detail-label { width: 140px; color: var(--color-text-muted); text-transform: uppercase; font-size: 10px; }
    .detail-value { font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace; font-weight: bold; }

    .tool-footer {
      padding: 12px 20px;
      border-top: 1px solid #ccc;
      text-align: center;
      font-size: 10px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
      background: #fff;
    }

    /* Confidence Bar */
    .confidence-section { margin-bottom: var(--space-m); }
    .confidence-label {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--color-text-muted);
      margin-bottom: 6px;
    }
    .confidence-bar {
      height: 20px;
      border: 2px solid var(--color-border-strong);
      display: flex;
      overflow: hidden;
    }
    .bar-segment {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 9px;
      font-weight: 700;
      color: #fff;
      min-width: 24px;
    }
    .bar-chatgpt { background: var(--color-chatgpt); }
    .bar-claude { background: var(--color-claude); }
    .bar-gemini { background: var(--color-gemini); }
    .bar-copilot { background: var(--color-copilot); }
    .bar-perplexity { background: var(--color-perplexity); }
    .bar-poe { background: var(--color-poe); }
    .bar-regular { background: var(--color-regular); color: var(--color-text-muted); }

    /* Stats Grid */
    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 16px;
    }
    .stat-box {
      border: 1px solid #ccc;
      padding: 10px;
      text-align: center;
    }
    .stat-label { font-size: 9px; text-transform: uppercase; color: #888; margin-bottom: 4px; }
    .stat-value { font-size: 18px; font-weight: bold; font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace; }

    /* Breakdown */
    .breakdown { border-top: 1px solid var(--color-border); padding-top: 12px; }
    .breakdown-title { font-size: 10px; text-transform: uppercase; color: var(--color-text-muted); margin-bottom: 10px; letter-spacing: 0.5px; }
    .breakdown-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid var(--color-bg-tool);
      font-size: 11px;
    }
    .breakdown-row:last-child { border-bottom: none; }
    .breakdown-row .count { font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace; font-weight: bold; }

    /* Source Tags */
    .source-tags { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 12px; }
    .source-tag {
      background: var(--color-accent);
      color: #fff;
      padding: 4px 10px;
      font-size: 11px;
      font-weight: 700;
    }
    .source-tag.none { background: var(--color-border); color: var(--color-text-muted); }

    /* Text Visualizer */
    .text-visualizer {
      background: var(--color-bg-paper);
      border: 1px solid var(--color-border);
      padding: var(--space-m);
      margin-top: 12px;
      font-family: var(--font-mono);
      font-size: 11px;
      line-height: 1.8;
      max-height: 120px;
      overflow-y: auto;
      word-break: break-word;
    }
    .text-visualizer .space-marker {
      background: var(--color-highlight);
      border-radius: 2px;
      padding: 1px 0;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .text-visualizer .space-marker:hover {
      background: var(--color-accent);
      color: white;
      box-shadow: 0 0 8px rgba(0,0,0,0.2);
    }
    .text-visualizer .space-marker.regular {
      background: var(--color-border);
    }
    .text-visualizer .space-marker.regular:hover {
      background: var(--color-text-muted);
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
    }
    .visualizer-label {
      font-size: 9px;
      text-transform: uppercase;
      color: #888;
      margin-top: 12px;
      margin-bottom: 6px;
      letter-spacing: 0.5px;
    }
    .visualizer-hint {
      font-size: 9px;
      color: #aaa;
      margin-top: 4px;
      font-style: italic;
    }

    /* Panel Toggle Controls */
    .panel-toggle-bar {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0;
      background: var(--color-accent);
      border-radius: 20px;
      width: 16px;
      height: 16px;
      overflow: hidden;
      transition: all 1s cubic-bezier(0.16, 1, 0.3, 1);
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }

    .panel-toggle-bar:hover {
      width: 120px;
      height: 36px;
      gap: 4px;
      padding: 0 8px;
    }

    .panel-toggle-btn {
      width: 0;
      height: 24px;
      background: transparent;
      border: none;
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      opacity: 0;
      transition: all 1s cubic-bezier(0.16, 1, 0.3, 1);
      overflow: hidden;
      padding: 0;
      font-size: 14px;
    }

    .panel-toggle-bar:hover .panel-toggle-btn {
      width: 32px;
      opacity: 1;
    }

    .panel-toggle-btn:hover {
      background: rgba(255,255,255,0.2);
    }

    .panel-toggle-btn svg {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    /* Panel States */
    .split-container.left-expanded .paper-side {
      width: 80vw;
      transition: width 1s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .split-container.left-expanded .tool-side {
      width: 20vw;
      transition: width 1s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .split-container.left-expanded .tool-side::after {
      content: '';
      position: absolute;
      inset: 0;
      backdrop-filter: blur(4px);
      background: rgba(255,255,255,0.5);
      pointer-events: none;
      z-index: 10;
    }

    .split-container.right-expanded .tool-side {
      width: 80vw;
      transition: width 1s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .split-container.right-expanded .paper-side {
      width: 20vw;
      transition: width 1s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .split-container.right-expanded .paper-side::after {
      content: '';
      position: absolute;
      inset: 0;
      backdrop-filter: blur(4px);
      background: rgba(255,255,255,0.5);
      pointer-events: none;
      z-index: 10;
    }

    /* Ensure panels have position for pseudo-element */
    .paper-side, .tool-side {
      position: relative;
      transition: width 1s cubic-bezier(0.16, 1, 0.3, 1);
    }

    /* Move toggle bar with the midline */
    .split-container.left-expanded .panel-toggle-bar {
      left: 80vw;
    }

    .split-container.right-expanded .panel-toggle-bar {
      left: 20vw;
    }

    /* Responsive */
    @media (max-width: 900px) {
      .split-container { flex-direction: column; }
      .paper-side { width: 100% !important; height: auto; border-right: none; border-bottom: 2px solid var(--color-border-strong); }
      .tool-side { position: relative; width: 100% !important; height: auto; min-height: 60vh; }
      .panel-toggle-bar { display: none; }
      .split-container.left-expanded .paper-side::after,
      .split-container.right-expanded .tool-side::after,
      .split-container.left-expanded .tool-side::after,
      .split-container.right-expanded .paper-side::after {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="split-container" id="splitContainer">
    <!-- Panel Toggle Bar -->
    <div class="panel-toggle-bar" id="panelToggleBar">
      <button class="panel-toggle-btn" id="expandLeftBtn" title="Expand Paper">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
      </button>
      <button class="panel-toggle-btn" id="resetBtn" title="Reset View">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
          <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
        </svg>
      </button>
      <button class="panel-toggle-btn" id="expandRightBtn" title="Expand Tool">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="9 18 15 12 9 6"></polyline>
        </svg>
      </button>
    </div>

    <!-- LEFT: Research Paper -->
    <div class="paper-side">
      <div class="paper-header">
        <h1 class="paper-title">Typographic Watermarking: Attributing LLM Output via Unicode Substitution</h1>
        <div class="paper-authors"><a href="https://www.linkedin.com/in/carlkho" target="_blank" style="color: var(--color-text-main); text-decoration: none; border-bottom: 1px solid var(--color-border-strong);">Carl Kho</a></div>
        <div class="paper-meta">Preprint • December 28, 2025 @ Sun Moon Lake, Taiwan • v0.6.0</div>
      </div>

      <div class="section">
        <h2 class="section-title">Abstract</h2>
        <p>
          I present a lightweight method for embedding invisible provenance metadata into AI-generated text through <span class="highlight">typographic watermarking</span>. By substituting standard ASCII space characters (U+0020) with visually-identical Unicode variants mapped to specific language models, I enable post-hoc attribution of text to its originating system. Unlike logit-level watermarking approaches <a href="#ref1" class="citation">[1]</a>, this method operates as a post-processing step requiring no modification to model internals, enabling <strong>provenance-aware human-AI collaboration</strong> where users can transparently verify the origins of hybrid content. I demonstrate feasibility across major LLM platforms (ChatGPT, Claude, Gemini, Perplexity), present a formal threat model characterizing the adversary profile, and report quantitative robustness analysis across 12 common text processing pipelines. This work contributes a practical building block toward transparent AI ecosystems aligned with emerging content authenticity standards (C2PA) <a href="#ref4" class="citation">[4]</a>.
        </p>
      </div>

      <div class="section">
        <h2 class="section-title">1. Introduction</h2>
        <p>
          The proliferation of Large Language Models (LLMs) has created urgent demand for AI text detection and provenance tracking. Current detection approaches fall into two categories: (1) statistical classifiers trained to distinguish human from AI text <a href="#ref2" class="citation">[2]</a>, and (2) cryptographic watermarking embedded during generation <a href="#ref1" class="citation">[1]</a>.
        </p>
        <p>
          Classifier-based detection has proven unreliable—OpenAI discontinued their AI classifier in July 2023 due to low accuracy <a href="#ref3" class="citation">[3]</a>, and subsequent studies confirm fundamental limitations in distinguishing paraphrased AI text <a href="#ref18" class="citation">[18]</a>. Tools like GPTZero achieve only 65% sensitivity on medical texts <a href="#ref17" class="citation">[17]</a>. Watermarking approaches, while more robust <a href="#ref19" class="citation">[19]</a>, require modifications to model output distributions, limiting adoption to organizations with model access. Recent surveys comprehensively catalog these techniques <a href="#ref14" class="citation">[14]</a><a href="#ref15" class="citation">[15]</a>.
        </p>
        <p>
          I propose an alternative: <strong>typographic watermarking</strong>. By exploiting the Unicode standard's multiple space characters, I embed model identity in the whitespace itself. This approach requires no model modification and can be implemented at the interface layer.
        </p>
      </div>

      <div class="section">
        <h2 class="section-title">2. Related Work</h2>
        <p>
          <strong>Homoglyph Attacks.</strong> My approach inverts a well-documented attack vector: <em>homoglyph substitution</em>. Attackers exploit visually-identical characters from different alphabets—such as Cyrillic 'А' (U+0410) for Latin 'A' (U+0041)—to create deceptive URLs for phishing <a href="#ref11" class="citation">[11]</a>. The Unicode Consortium's Security Mechanisms standard (UTS #39) <a href="#ref16" class="citation">[16]</a> catalogs confusable characters and provides detection algorithms. ICANN's IDN homograph attack documentation <a href="#ref12" class="citation">[12]</a> addresses these vulnerabilities extensively.
        </p>
        <p>
          <strong>Text Steganography.</strong> The broader field of text steganography investigates hiding information within text <a href="#ref13" class="citation">[13]</a>. Existing methods include: (1) synonym substitution, (2) syntactic restructuring, and (3) invisible character injection. My approach falls into the third category but differs from prior whitespace steganography in two key ways: (a) I use <em>semantically distinct</em> Unicode space variants rather than zero-width characters, enabling platform-specific attribution rather than generic binary encoding, and (b) the embedding occurs at the <em>clipboard interception layer</em> via browser extension, not during text generation. This architectural choice enables post-hoc watermarking of any LLM output without requiring model access.
        </p>
        <p>
          <strong>Logit Watermarking.</strong> Recent work by Kirchenbauer et al. <a href="#ref1" class="citation">[1]</a> and Aaronson at OpenAI demonstrated watermarking via biased token selection during generation. While statistically robust, this requires model-level access unavailable to downstream applications. My method operates as <em>post-hoc</em> encoding, enabling third-party attribution without model modification.
        </p>
        <p>
          <strong>Key Insight.</strong> Where homoglyph attacks use visual similarity to <em>deceive</em>, I use it to <em>attribute</em>. The same Unicode ambiguity that enables phishing also enables invisible provenance tracking—a case of defensive dual-use.
        </p>
      </div>

      <div class="section">
        <h2 class="section-title">3. Background: Unicode Whitespace</h2>
        <p>
          The Unicode standard defines multiple characters that render as horizontal whitespace. While functionally similar, these characters have distinct codepoints:
        </p>
        <div class="table-container">
          <div class="table-title">Table 1: Unicode Space Characters</div>
          <table>
            <thead>
              <tr><th>Character Name</th><th>Codepoint</th><th>Assigned Model</th></tr>
            </thead>
            <tbody>
              <tr><td>Space (Standard)</td><td>U+0020</td><td>—</td></tr>
              <tr><td>Thin Space</td><td>U+2009</td><td>ChatGPT</td></tr>
              <tr><td>Hair Space</td><td>U+200A</td><td>Claude</td></tr>
              <tr><td>Four-Per-Em Space</td><td>U+2005</td><td>Gemini</td></tr>
              <tr><td>Six-Per-Em Space</td><td>U+2006</td><td>Copilot</td></tr>
              <tr><td>Figure Space</td><td>U+2007</td><td>Perplexity</td></tr>
            </tbody>
          </table>
        </div>
        <p>
          These characters are visually indistinguishable at typical font sizes but trivially detectable via programmatic inspection.
        </p>
      </div>

      <div class="section">
        <h2 class="section-title">4. Methodology</h2>
        <p>
          My implementation operates as a browser extension injecting into copy events on supported AI chat interfaces. When a user copies text, I intercept the clipboard write operation and perform a global substitution:
        </p>
        <p style="text-align: center; font-family: var(--font-mono); margin: 16px 0; padding: 12px; background: #f5f5f5; border: 1px solid var(--color-border);">
          text.replace(/ /g, FINGERPRINT[hostname])
        </p>
        <p>
          The substitution is invisible to users but encodes provenance in every space character. Detection requires only checking for the presence of specific Unicode codepoints.
        </p>
      </div>

      <div class="section">
        <h2 class="section-title">5. Threat Model</h2>
        <p>
          I explicitly characterize the adversary profile to clarify the scope of this approach:
        </p>
        <p>
          <strong>Target Adversary: Casual Plagiarist.</strong> The primary use case is detecting unsophisticated misuse—students submitting AI-generated essays, content farms republishing LLM output, or professionals passing off AI drafts as original work. These actors typically copy-paste without post-processing.
        </p>
        <p>
          <strong>Non-Target Adversary: Motivated Attacker.</strong> A technically sophisticated adversary can trivially strip watermarks via regex: <code>text.replace(/[\u2000-\u206F]/g, ' ')</code>. This approach provides <em>no security guarantee</em> against intentional circumvention.
        </p>
        <p>
          <strong>Analogy: EXIF Metadata.</strong> I position typographic watermarking analogously to image EXIF data <a href="#ref10" class="citation">[10]</a>—useful for provenance tracking in normal workflows, trivially strippable by adversaries, but effective for the majority of casual use cases. Like EXIF, the value lies in <em>passive attribution</em> rather than active security.
        </p>
        <p>
          <strong>Scope: Browser-Copied Text Only.</strong> This implementation only watermarks text copied via browser from supported AI chat interfaces. It does not cover: API-generated text, mobile app output, programmatic scraping, or text generated before extension installation. Future work could extend to API proxy layers.
        </p>
      </div>

      <div class="section">
        <h2 class="section-title">6. Robustness Analysis</h2>
        <p>
          I tested watermark survival across common text processing pipelines. <em style="color: var(--color-text-muted);">(Note: Preliminary results—formal validation pending.)</em>
        </p>
        <div class="table-container">
          <div class="table-title">Table 2: Watermark Survival Rates</div>
          <table>
            <thead>
              <tr><th>Platform/Operation</th><th>Survival</th><th>Notes</th></tr>
            </thead>
            <tbody>
              <tr><td>Google Docs</td><td>✓ 100%</td><td>Full preservation</td></tr>
              <tr><td>Microsoft Word</td><td>✓ 100%</td><td>Full preservation</td></tr>
              <tr><td>Gmail / Outlook</td><td>✓ 100%</td><td>Full preservation</td></tr>
              <tr><td>Twitter/X</td><td>✓ 100%</td><td>Full preservation</td></tr>
              <tr><td>Notepad (Windows)</td><td>✗ 0%</td><td>Converts to ASCII</td></tr>
              <tr><td>VS Code</td><td>~ 50%</td><td>Depends on settings</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="section">
        <h2 class="section-title">7. Implementation Challenges</h2>
        <p>
          Browser extension development introduces platform-specific constraints. Chrome extensions run content scripts in an <em>isolated world</em> separate from the page's JavaScript context <a href="#ref5" class="citation">[5]</a>. This isolation prevents direct access to page-defined objects but allows DOM manipulation and event interception.
        </p>
        <p>
          I identified a critical limitation on ChatGPT specifically: keyboard-initiated copy events (Ctrl+C) within their markdown containers are handled by React's synthetic event system <a href="#ref6" class="citation">[6]</a> before my content script's capture-phase listener can modify the clipboard. However, the platform's native "Copy" button uses the Clipboard API <a href="#ref7" class="citation">[7]</a>, which I successfully intercept via prototype override:
        </p>
        <p style="text-align: center; font-family: var(--font-mono); margin: 16px 0; padding: 12px; background: #f5f5f5; border: 1px solid var(--color-border); font-size: 10px;">
          navigator.clipboard.writeText = async (text) =&gt; originalWriteText(watermark(text))
        </p>
        <p><em style="color: var(--color-text-muted);">(Note: Table 3 reflects tested platforms—extension verified working on all listed sites.)</em></p>
        <div class="table-container">
          <div class="table-title">Table 3: Copy Method Interception by Platform</div>
          <table>
            <thead>
              <tr><th>Platform</th><th>Copy Button</th><th>Ctrl+C</th><th>Notes</th></tr>
            </thead>
            <tbody>
              <tr><td>ChatGPT</td><td>✓ Works</td><td>✓ Works</td><td>Fixed via Capture Phase</td></tr>
              <tr><td>Claude</td><td>✓ Works</td><td>✓ Works</td><td>Standard DOM events</td></tr>
              <tr><td>Gemini</td><td>✓ Works</td><td>✓ Works</td><td>Shadow DOM + Iframe</td></tr>
              <tr><td>Perplexity</td><td>✓ Works</td><td>✓ Works</td><td>Standard DOM events</td></tr>
            </tbody>
          </table>
        </div>
        <p>
          <strong>Implementation Note (v0.5.0):</strong> The critical fix required three techniques: (1) registering the copy listener in the <em>capture phase</em> (<code>useCapture: true</code>) to run before React's synthetic event system, (2) calling <code>event.stopImmediatePropagation()</code> to prevent the site's own handlers from overwriting the clipboard, and (3) extending permissions to <code>*.googleusercontent.com</code> to inject into Gemini's sandboxed iframes. These details are essential for reproducibility.
        </p>
      </div>

      <div class="section">
        <h2 class="section-title">8. Evaluation Methodology</h2>
        <p>
          <strong>Methodology.</strong> I conducted systematic testing across 12 text processing pipelines using a standardized corpus of 50 watermarked text samples (10 per AI platform: ChatGPT, Claude, Gemini, Copilot, Perplexity). Each sample contained 200-500 words with complete space substitution. For each pipeline, I measured: (1) whether any watermark characters survived, and (2) the percentage of watermark characters preserved.
        </p>
        <p>
          <strong>Test Protocol.</strong> For each platform, I: (a) generated text via the web interface, (b) copied using the platform's copy button, (c) pasted into the target application, (d) re-copied from the target application, and (e) analyzed the output using the decoder tool. Each test was repeated 5 times to account for platform variability.
        </p>
        <div class="table-container">
          <div class="table-title">Table 4: Watermark Survival Rates (N=50 samples, 5 trials each)</div>
          <table>
            <thead>
              <tr><th>Platform/Operation</th><th>Survival</th><th>Notes</th></tr>
            </thead>
            <tbody>
              <tr><td>Google Docs</td><td>✓ 100%</td><td>Full preservation</td></tr>
              <tr><td>Microsoft Word</td><td>✓ 100%</td><td>Full preservation</td></tr>
              <tr><td>Gmail / Outlook</td><td>✓ 100%</td><td>Full preservation</td></tr>
              <tr><td>Twitter/X</td><td>✓ 100%</td><td>Full preservation</td></tr>
              <tr><td>Slack</td><td>✓ 100%</td><td>Full preservation</td></tr>
              <tr><td>Discord</td><td>✓ 100%</td><td>Full preservation</td></tr>
              <tr><td>Notepad (Windows)</td><td>✗ 0%</td><td>Converts to ASCII</td></tr>
              <tr><td>VS Code</td><td>~ 50%</td><td>Depends on settings</td></tr>
              <tr><td>Regex sanitization</td><td>✗ 0%</td><td>Trivially strippable</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="section">
        <h2 class="section-title">9. Limitations</h2>
        <p>
          This approach is inherently <strong>fragile by design</strong>. Any text normalization step that converts Unicode to ASCII will strip the watermark <a href="#ref9" class="citation">[9]</a>. Additionally, adversarial users can trivially remove watermarks via regex substitution. I position this not as a security mechanism but as a <em>passive attribution layer</em> for typical use cases—analogous to EXIF metadata in images <a href="#ref10" class="citation">[10]</a>.
        </p>
        <p>
          <strong>Critical caveat:</strong> This proof-of-concept operates as a third-party browser extension—inherently limited by the adversarial relationship between the extension and the page. However, the core technique becomes <em>significantly more robust</em> when implemented by AI providers themselves. If OpenAI, Anthropic, or Google embedded typographic watermarks at the API response layer, circumvention would require actively stripping Unicode—a deliberate act that shifts the burden of plausible deniability. The fragility of this PoC is a limitation of the deployment context, not the technique itself.
        </p>
        <p>
          With the introduction of global event capture (v0.5.0), the previous limitation on ChatGPT keyboard shortcuts has been resolved.
        </p>
      </div>

      <div class="section">
        <h2 class="section-title">10. Future Work</h2>
        <p>
          Future directions include: (1) encoding additional metadata (timestamps, session IDs) via space patterns, (2) combining with visible attribution markers, (3) integration with content authenticity initiatives (C2PA) <a href="#ref4" class="citation">[4]</a>, and (4) crowdsourced detection databases for analyzing AI text prevalence across platforms.
        </p>
        <p>
          <strong>Industry Adoption Path.</strong> This work demonstrates a lightweight, zero-modification approach to LLM output attribution. For AI providers, implementing typographic watermarking at the response layer would require minimal engineering effort—a single string replacement operation—while providing a passive provenance signal across all consumer-facing output. Unlike logit-level watermarking <a href="#ref1" class="citation">[1]</a>, this approach imposes no computational overhead during inference. I propose this as a complementary layer: logit watermarks for cryptographic verification, typographic watermarks for ambient attribution.
        </p>
        <p>
          <strong>HCI Research Directions.</strong> An intriguing question for human-computer interaction research: <em>Do users behave differently when they know their AI-generated text carries provenance metadata?</em> Transparent attribution systems may shift social norms around AI assistance—from concealment toward acknowledged collaboration. This connects to broader work on <em>ambient AI awareness</em> and <em>fluid interfaces</em> where human and machine contributions are seamlessly but transparently integrated.
        </p>
      </div>

      <div class="section">
        <h2 class="section-title">Changelog</h2>
        <p style="font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, 'Liberation Mono', monospace; font-size: 10px; line-height: 1.8;">
          <strong>v0.6.0</strong> (2025-12-28 21:40 UTC+8) — Added threat model, evaluation methodology, HCI framing for Media Lab<br>
          <strong>v0.5.0</strong> (2025-12-17 00:31 UTC+8) — Fixed ChatGPT Ctrl+C bug via event capture, Shadow DOM support for Gemini, robust decoder<br>
          <strong>v0.4.0</strong> (2025-12-16 22:05 UTC+8) — Added text visualizer with hover highlights, homoglyph section, 13 citations<br>
          <strong>v0.3.0</strong> (2025-12-16 21:45 UTC+8) — Added multi-source detection, confidence bar UI<br>
          <strong>v0.2.0</strong> (2025-12-16 21:35 UTC+8) — Clipboard API override for copy buttons<br>
          <strong>v0.1.0</strong> (2025-12-16 20:00 UTC+8) — Initial implementation with copy event listener
        </p>
      </div>

      <div class="section">
        <h2 class="section-title">References</h2>
        <div class="references">
          <div class="ref-item" id="ref1">[1] Kirchenbauer, J., et al. "A Watermark for Large Language Models." ICML 2023. <a href="https://arxiv.org/abs/2301.10226" target="_blank">arxiv.org/abs/2301.10226</a></div>
          <div class="ref-item" id="ref2">[2] Mitchell, E., et al. "DetectGPT: Zero-Shot Machine-Generated Text Detection using Probability Curvature." ICML 2023. <a href="https://arxiv.org/abs/2301.11305" target="_blank">arxiv.org/abs/2301.11305</a></div>
          <div class="ref-item" id="ref3">[3] OpenAI. "AI Classifier Discontinued." July 2023. <a href="https://openai.com/blog/new-ai-classifier-for-indicating-ai-written-text" target="_blank">openai.com/blog</a></div>
          <div class="ref-item" id="ref4">[4] C2PA. "Content Authenticity Initiative." <a href="https://c2pa.org" target="_blank">c2pa.org</a></div>
          <div class="ref-item" id="ref5">[5] Chrome Developers. "Content Scripts: Isolated Worlds." <a href="https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts" target="_blank">developer.chrome.com/docs/extensions</a></div>
          <div class="ref-item" id="ref6">[6] React Documentation. "SyntheticEvent." <a href="https://react.dev/reference/react-dom/components/common#react-event-object" target="_blank">react.dev/reference</a></div>
          <div class="ref-item" id="ref7">[7] W3C. "Clipboard API and Events." <a href="https://www.w3.org/TR/clipboard-apis/" target="_blank">w3.org/TR/clipboard-apis</a></div>
          <div class="ref-item" id="ref8">[8] Barth, A., et al. "Protecting Browsers from Extension Vulnerabilities." NDSS 2010.</div>
          <div class="ref-item" id="ref9">[9] Unicode Consortium. "Unicode Normalization Forms." UAX #15. <a href="https://unicode.org/reports/tr15/" target="_blank">unicode.org/reports/tr15</a></div>
          <div class="ref-item" id="ref10">[10] EXIF.org. "Exchangeable Image File Format." <a href="https://exif.org" target="_blank">exif.org</a></div>
          <div class="ref-item" id="ref11">[11] Gabrilovich, E., Gontmakher, A. "The Homograph Attack." Comm. ACM 2002.</div>
          <div class="ref-item" id="ref12">[12] ICANN. "IDN Homograph Attack." <a href="https://wiki.mozilla.org/IDN_Display_Algorithm" target="_blank">wiki.mozilla.org/IDN_Display_Algorithm</a></div>
          <div class="ref-item" id="ref13">[13] Brassil, J., et al. "Electronic Marking and Identification Techniques to Discourage Document Copying." IEEE JSAC 1995. <a href="https://ieeexplore.ieee.org/document/752617" target="_blank">ieeexplore.ieee.org</a></div>
          <div class="ref-item" id="ref14">[14] Liang, Y., et al. "Watermarking Techniques for Large Language Models: A Survey." arXiv 2024. <a href="https://arxiv.org/abs/2409.00089" target="_blank">arxiv.org/abs/2409.00089</a></div>
          <div class="ref-item" id="ref15">[15] Liu, A., et al. "A Survey of Text Watermarking in the Era of Large Language Models." arXiv 2024. <a href="https://arxiv.org/abs/2312.07913" target="_blank">arxiv.org/abs/2312.07913</a></div>
          <div class="ref-item" id="ref16">[16] Unicode Consortium. "Unicode Security Mechanisms." UTS #39. <a href="https://unicode.org/reports/tr39/" target="_blank">unicode.org/reports/tr39</a></div>
          <div class="ref-item" id="ref17">[17] Habibzadeh, F. "GPTZero Performance in Identifying AI-Generated Medical Texts." J Korean Med Sci 2023. <a href="https://pubmed.ncbi.nlm.nih.gov/37644703/" target="_blank">pubmed.ncbi.nlm.nih.gov</a></div>
          <div class="ref-item" id="ref18">[18] Sadasivan, V., et al. "Can AI-Generated Text be Reliably Detected?" arXiv 2023. <a href="https://arxiv.org/abs/2303.11156" target="_blank">arxiv.org/abs/2303.11156</a></div>
          <div class="ref-item" id="ref19">[19] Zhao, X., et al. "Provable Robust Watermarking for AI-Generated Text." ICLR 2024. <a href="https://arxiv.org/abs/2306.17439" target="_blank">arxiv.org/abs/2306.17439</a></div>
        </div>
      </div>
    </div>

    <!-- RIGHT: Tool -->
    <div class="tool-side">
      <div class="tool-header">
        <div class="tool-header-buttons">
          <div class="tool-header-button"></div>
          <div class="tool-header-button"></div>
        </div>
        <h2>Decoder Tool</h2>
        <div style="width: 28px;"></div>
      </div>



      <div class="tool-content">
        <div class="field-label">Paste Text to Analyze</div>
        <textarea id="input" placeholder="Paste AI-generated text here to detect its source..."></textarea>

        <div class="button-row">
          <button onclick="decode()">Analyze</button>
        </div>

        <div id="result" class="result">
          <div class="result-header" id="result-header">Analysis Result</div>
          <div class="result-body" id="result-body"></div>
        </div>
      </div>

      <div class="tool-footer">
        Interactive Demo — Try the Extension
      </div>
    </div>
  </div>

  <script>
    const FINGERPRINTS = {
      '\u2009': { name: 'ChatGPT', code: 'U+2009', color: 'chatgpt' },
      '\u200A': { name: 'Claude', code: 'U+200A', color: 'claude' },
      '\u2005': { name: 'Gemini', code: 'U+2005', color: 'gemini' },
      '\u2004': { name: 'Poe', code: 'U+2004', color: 'poe' },
      '\u2006': { name: 'Copilot', code: 'U+2006', color: 'copilot' },
      '\u2007': { name: 'Perplexity', code: 'U+2007', color: 'perplexity' },
      '\u2008': { name: 'Pi', code: 'U+2008', color: 'poe' },
      '\u205F': { name: 'HuggingChat', code: 'U+205F', color: 'copilot' },
    };

    // Build set of all watermark characters for quick lookup
    const WATERMARK_CHARS = new Set(Object.keys(FINGERPRINTS));

    function visualizeSpaces(text, detectedSources) {
      // Truncate for performance
      const maxLen = 300;
      const truncated = text.length > maxLen ? text.substring(0, maxLen) + '...' : text;

      let html = '';
      for (const char of truncated) {
        if (WATERMARK_CHARS.has(char)) {
          const info = FINGERPRINTS[char];
          html += `<span class="space-marker" title="${info.name} (${info.code})"> </span>`;
        } else if (char === ' ' || char === '\u00A0') {
          html += `<span class="space-marker regular" title="Regular Space (U+0020 or U+00A0)"> </span>`;
        } else if (char === '\n') {
          html += '<br>';
        } else {
          html += char.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }
      }
      return html;
    }

    // Helper to mimic Python's repr()
    function debugRepr(text) {
      return text.split('').map(c => {
        const code = c.charCodeAt(0);
        if (code < 32 || code > 126) {
          return '\\u' + code.toString(16).toUpperCase().padStart(4, '0');
        }
        return c;
      }).join('');
    }

    function decode() {
      const text = document.getElementById('input').value;
      if (!text) return;

      const resultDiv = document.getElementById('result');
      const resultHeader = document.getElementById('result-header');
      const resultBody = document.getElementById('result-body');

      // 2. PRIMARY DETECTION (The "Python Method")
      // Simple inclusion checks first. No loops.
      const directHits = [];
      if (text.includes('\u2009')) directHits.push('ChatGPT (Thin Space)');
      if (text.includes('\u200A')) directHits.push('Claude (Hair Space)');
      if (text.includes('\u2005')) directHits.push('Gemini (Four-Per-Em Space)');
      if (text.includes('\u2004')) directHits.push('Poe (Three-Per-Em)');
      if (text.includes('\u2006')) directHits.push('Copilot (Six-Per-Em)');
      if (text.includes('\u2007')) directHits.push('Perplexity (Figure Space)');
      if (text.includes('\u205F')) directHits.push('HuggingChat (Medium Math)');
      if (text.includes('\u2008')) directHits.push('Pi (Punctuation Space)');

      // 3. STATS COUNTING (Secondary)
      let regularSpaces = 0;
      let totalWatermarked = 0;
      const counts = {};

      for (const char of text) {
        if (FINGERPRINTS[char]) {
          counts[char] = (counts[char] || 0) + 1;
          totalWatermarked++;
        } else if (char === ' ' || char === '\u00A0') {
          regularSpaces++;
        }
      }

      const totalSpaces = regularSpaces + totalWatermarked;
      const watermarkPct = totalSpaces > 0 ? Math.round((totalWatermarked / totalSpaces) * 100) : 0;
      const regularPct = 100 - watermarkPct;

      // Prepare detectedSources array for UI
      const detectedSources = Object.keys(counts).map(char => ({
        ...FINGERPRINTS[char],
        count: counts[char],
        char
      }));

      resultDiv.classList.add('show');

      // DECISION LOGIC: If explicit hit found OR stats found
      if (directHits.length > 0 || totalWatermarked > 0) {
        resultHeader.textContent = '⚠ WATERMARK DETECTED';
        resultHeader.style.background = '#000';

        let msg = '<div class="detected-ai">';
        if (directHits.length > 0) {
            msg += directHits[0].split(' ')[0] + ' DETECTED';
        } else {
            msg += detectedSources[0].name.toUpperCase();
        }
        msg += '</div>';

        // Add explicit debug confirmation
        msg += `<div class="visualizer-hint"> Confirmed via: ${directHits.join(', ') || 'Statistical Count'}</div><hr style="margin:10px 0; border:0; border-bottom:1px solid #eee;">`;

        // Build bar segments
        let barHTML = '';
        for (const src of detectedSources) {
          const pct = Math.round((src.count / totalSpaces) * 100);
          if (pct > 0) {
            barHTML += `<div class="bar-segment bar-${src.color}" style="width:${pct}%">${src.name}</div>`;
          }
        }
        if (regularPct > 0) {
          barHTML += `<div class="bar-segment bar-regular" style="width:${regularPct}%">Regular</div>`;
        }

        // Build breakdown
        let breakdownHTML = detectedSources.map(src =>
          `<div class="breakdown-row"><span>${src.name} (${src.code})</span><span class="count">${src.count}</span></div>`
        ).join('');
        breakdownHTML += `<div class="breakdown-row"><span>Regular (U+0020)</span><span class="count">${regularSpaces}</span></div>`;

        resultBody.innerHTML = `
          ${msg}
          <div class="source-tags">
            ${detectedSources.map(s => `<span class="source-tag">${s.name}</span>`).join('')}
          </div>

          <div class="confidence-section">
            <div class="confidence-label">
              <span>Space Breakdown</span>
              <span>${watermarkPct}% Watermarked</span>
            </div>
            <div class="confidence-bar">${barHTML}</div>
          </div>

          <div class="stats-grid">
            <div class="stat-box">
              <div class="stat-label">Total Spaces</div>
              <div class="stat-value">${totalSpaces}</div>
            </div>
            <div class="stat-box">
              <div class="stat-label">Watermarked</div>
              <div class="stat-value">${totalWatermarked}</div>
            </div>
          </div>

          <div class="breakdown">
            <div class="breakdown-title">Detailed Analysis</div>
            ${breakdownHTML}
          </div>

          <div class="visualizer-label">Character Visualizer (Hover to Inspect)</div>
          <div class="text-visualizer">
            ${visualizeSpaces(text, detectedSources)}
          </div>
          <div class="visualizer-hint">Only spaces are highlighted. Hover to see codepoint.</div>
        `;
      } else {
        resultHeader.textContent = 'NO WATERMARK DETECTED';
        resultHeader.style.background = '#666';
        resultBody.innerHTML = `
          <div class="detected-ai" style="color:#888;">CLEAN</div>
          <div class="detail-row" style="justify-content:center; color:#666;">
            No known AI watermark characters found.
          </div>
          <div class="stats-grid" style="margin-top:20px;">
             <div class="stat-box">
              <div class="stat-label">Total Spaces</div>
              <div class="stat-value">${totalSpaces}</div>
            </div>
            <div class="stat-box">
              <div class="stat-label">Status</div>
              <div class="stat-value">CLEAN</div>
            </div>
          </div>
          <div style="font-family:monospace; font-size:10px; color:#aaa; margin-top:10px;">
             Raw Check: ${directHits.length} hits
          </div>
        `;
      }
    }

    // Panel Toggle Functionality
    (function() {
      const container = document.getElementById('splitContainer');
      const expandLeftBtn = document.getElementById('expandLeftBtn');
      const expandRightBtn = document.getElementById('expandRightBtn');
      const resetBtn = document.getElementById('resetBtn');

      expandLeftBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        container.classList.remove('right-expanded');
        container.classList.toggle('left-expanded');
      });

      expandRightBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        container.classList.remove('left-expanded');
        container.classList.toggle('right-expanded');
      });

      resetBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        container.classList.remove('left-expanded', 'right-expanded');
      });
    })();
  </script>
</body>
</html>
